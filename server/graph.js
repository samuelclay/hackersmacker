// Generated by CoffeeScript 2.6.1
(function() {
  var USER_FOED_BY, USER_FOES_WITH, USER_FRIENDED_BY, USER_FRIENDS_WITH, client, redis,
    indexOf = [].indexOf;

  redis = require('redis');

  client = redis.createClient(null, process.env.REDIS_HOST || null);

  USER_FRIENDS_WITH = "F";

  USER_FRIENDED_BY = "f";

  USER_FOES_WITH = "X";

  USER_FOED_BY = "x";

  module.exports = {
    saveRelationship: function(originalUsername, relationship, username) {
      var foedBy, foesWith, friendedBy, friendsWith;
      console.log(` ---> [${originalUsername}] Adding ${username} as a ${relationship}.`);
      friendsWith = `G:${originalUsername}:${USER_FRIENDS_WITH}`;
      friendedBy = `G:${username}:${USER_FRIENDED_BY}`;
      foesWith = `G:${originalUsername}:${USER_FOES_WITH}`;
      foedBy = `G:${username}:${USER_FOED_BY}`;
      if (relationship === 'friend') {
        client.sadd(friendsWith, username);
        client.sadd(friendedBy, originalUsername);
        client.srem(foesWith, username);
        return client.srem(foedBy, originalUsername);
      } else if (relationship === 'foe') {
        client.srem(friendsWith, username);
        client.srem(friendedBy, originalUsername);
        client.sadd(foesWith, username);
        return client.sadd(foedBy, originalUsername);
      } else if (relationship === 'neutral') {
        client.srem(friendsWith, username);
        client.srem(friendedBy, originalUsername);
        client.srem(foesWith, username);
        return client.srem(foedBy, originalUsername);
      }
    },
    saveRatingContext: function(originalUsername, relationship, username, context) {
      var foesHistory, friendsHistory, ratingKey, timestamp;
      ratingKey = `R:${originalUsername}:${username}`;
      timestamp = Math.floor(Date.now() / 1000);
      friendsHistory = `H:${originalUsername}:F`;
      foesHistory = `H:${originalUsername}:X`;
      if (relationship === 'neutral') {
        client.del(ratingKey);
        client.zrem(friendsHistory, username);
        client.zrem(foesHistory, username);
        return;
      }
      client.hmset(ratingKey, 'relationship', relationship, 'comment_text', (context.comment_text || '').substring(0, 500), 'comment_url', context.comment_url || '', 'thread_title', context.thread_title || '', 'thread_url', context.thread_url || '', 'parent_author', context.parent_author || '', 'timestamp', String(timestamp));
      if (relationship === 'friend') {
        client.zadd(friendsHistory, timestamp, username);
        return client.zrem(foesHistory, username);
      } else if (relationship === 'foe') {
        client.zadd(foesHistory, timestamp, username);
        return client.zrem(friendsHistory, username);
      }
    },
    getProfile: function(username, callback) {
      var enrichAndReturn, foesWith, friendsWith, settingsKey;
      friendsWith = `G:${username}:${USER_FRIENDS_WITH}`;
      foesWith = `G:${username}:${USER_FOES_WITH}`;
      settingsKey = `U:${username}`;
      // Enrichment: check if each friend/foe has their own HS profile
      enrichAndReturn = function(profile, cb) {
        var allNames, f, j, len, multi, name;
        allNames = ((function() {
          var j, len, ref, results1;
          ref = profile.friends;
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            f = ref[j];
            results1.push(f.name);
          }
          return results1;
        })()).concat((function() {
          var j, len, ref, results1;
          ref = profile.foes;
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            f = ref[j];
            results1.push(f.name);
          }
          return results1;
        })());
        if (allNames.length === 0) {
          return cb(profile);
        }
        multi = client.multi();
        for (j = 0, len = allNames.length; j < len; j++) {
          name = allNames[j];
          multi.scard(`G:${name}:${USER_FRIENDS_WITH}`);
          multi.scard(`G:${name}:${USER_FOES_WITH}`);
        }
        return multi.exec(function(e, results) {
          var has, idx, k, l, len1, len2, len3, n, ref, ref1;
          for (idx = k = 0, len1 = allNames.length; k < len1; idx = ++k) {
            name = allNames[idx];
            has = (results[idx * 2] || 0) > 0 || (results[idx * 2 + 1] || 0) > 0;
            ref = profile.friends;
            for (l = 0, len2 = ref.length; l < len2; l++) {
              f = ref[l];
              if (f.name === name) {
                f.hasProfile = has;
              }
            }
            ref1 = profile.foes;
            for (n = 0, len3 = ref1.length; n < len3; n++) {
              f = ref1[n];
              if (f.name === name) {
                f.hasProfile = has;
              }
            }
          }
          return cb(profile);
        });
      };
      return client.hgetall(settingsKey, function(e, settings) {
        var profile;
        profile = {
          settings: settings || {
            profile_public: '1'
          },
          friends: [],
          foes: []
        };
        // Get all friends from both G: set and H: sorted set
        return client.smembers(friendsWith, function(e, allFriends) {
          allFriends = allFriends || [];
          return client.zrevrangebyscore(`H:${username}:F`, '+inf', '-inf', 'WITHSCORES', function(e, friendsWithScores) {
            var fetchFoes, friendNames, i, j, len, name, remaining, results1, timestampMap;
            // Build friends list with timestamps from sorted set
            timestampMap = {};
            if (friendsWithScores) {
              i = 0;
              while (i < friendsWithScores.length) {
                timestampMap[friendsWithScores[i]] = friendsWithScores[i + 1];
                i += 2;
              }
            }
            // Merge: all friends from G: set, with timestamps from H: if available
            friendNames = allFriends;
// Add any from H: that might not be in G: (shouldn't happen but be safe)
            for (name in timestampMap) {
              if (indexOf.call(friendNames, name) < 0) {
                friendNames.push(name);
              }
            }
            // Define fetchFoes before use (CoffeeScript var hoisting)
            fetchFoes = function() {
              // Sort friends by timestamp desc (those with timestamps first)
              profile.friends.sort(function(a, b) {
                var ta, tb;
                ta = a.timestamp ? parseInt(a.timestamp) : 0;
                tb = b.timestamp ? parseInt(b.timestamp) : 0;
                return tb - ta;
              });
              // Now get foes
              return client.smembers(foesWith, function(e, allFoes) {
                allFoes = allFoes || [];
                return client.zrevrangebyscore(`H:${username}:X`, '+inf', '-inf', 'WITHSCORES', function(e, foesWithScores) {
                  var foeNames, foeRemaining, foeTimestampMap, j, len, results1;
                  foeTimestampMap = {};
                  if (foesWithScores) {
                    i = 0;
                    while (i < foesWithScores.length) {
                      foeTimestampMap[foesWithScores[i]] = foesWithScores[i + 1];
                      i += 2;
                    }
                  }
                  foeNames = allFoes;
                  for (name in foeTimestampMap) {
                    if (indexOf.call(foeNames, name) < 0) {
                      foeNames.push(name);
                    }
                  }
                  foeRemaining = foeNames.length;
                  if (foeRemaining === 0) {
                    return enrichAndReturn(profile, callback);
                  }
                  results1 = [];
                  for (j = 0, len = foeNames.length; j < len; j++) {
                    name = foeNames[j];
                    results1.push((function(name) {
                      return client.hgetall(`R:${username}:${name}`, function(e, ctx) {
                        profile.foes.push({
                          name: name,
                          timestamp: foeTimestampMap[name] || null,
                          context: ctx || {}
                        });
                        foeRemaining--;
                        if (foeRemaining === 0) {
                          profile.foes.sort(function(a, b) {
                            var ta, tb;
                            ta = a.timestamp ? parseInt(a.timestamp) : 0;
                            tb = b.timestamp ? parseInt(b.timestamp) : 0;
                            return tb - ta;
                          });
                          return enrichAndReturn(profile, callback);
                        }
                      });
                    })(name));
                  }
                  return results1;
                });
              });
            };
            // Fetch context for each friend
            remaining = friendNames.length;
            if (remaining === 0) {
              return fetchFoes();
            }
            results1 = [];
            for (j = 0, len = friendNames.length; j < len; j++) {
              name = friendNames[j];
              results1.push((function(name) {
                return client.hgetall(`R:${username}:${name}`, function(e, ctx) {
                  profile.friends.push({
                    name: name,
                    timestamp: timestampMap[name] || null,
                    context: ctx || {}
                  });
                  remaining--;
                  if (remaining === 0) {
                    return fetchFoes();
                  }
                });
              })(name));
            }
            return results1;
          });
        });
      });
    },
    getProfileSettings: function(username, callback) {
      return client.hgetall(`U:${username}`, function(e, settings) {
        return callback(settings || {
          profile_public: '1'
        });
      });
    },
    setProfileVisibility: function(username, isPublic, callback) {
      return client.hset(`U:${username}`, 'profile_public', (isPublic ? '1' : '0'), function() {
        return typeof callback === "function" ? callback() : void 0;
      });
    },
    findRelationships: function(originalUsername, usernames, callback) {
      var foesWith, friendsWith, graph, multi1, multi2, onpageUserSet;
      multi1 = client.multi();
      multi2 = client.multi();
      graph = {
        friends: [],
        foes: [],
        foaf_friends: [],
        foaf_foes: []
      };
      onpageUserSet = `T:${originalUsername}:onpage`;
      friendsWith = `G:${originalUsername}:${USER_FRIENDS_WITH}`;
      foesWith = `G:${originalUsername}:${USER_FOES_WITH}`;
      // Store all users on the page in Redis to be used for set intersections
      return client.sadd(onpageUserSet, usernames, function(e, m) {
        // Match friends/foes of current user with users on page
        multi1.sinter(friendsWith, onpageUserSet, function(e, m) {
          if (m) {
            return graph.friends = graph.friends.concat(m);
          }
        });
        multi1.sinter(foesWith, onpageUserSet, function(e, m) {
          if (m) {
            return graph.foes = graph.foes.concat(m);
          }
        });
        // For each of the current user's friends, match the friend's friends/foes with users on the page
        multi1.smembers(friendsWith, function(e, m) {
          var friend, j, len;
          m = m || [];
          for (j = 0, len = m.length; j < len; j++) {
            friend = m[j];
            (function(friend) {
              multi2.sinter(`G:${friend}:${USER_FRIENDS_WITH}`, onpageUserSet, function(e, m) {
                if (m) {
                  return graph.foaf_friends = graph.foaf_friends.concat(m);
                }
              });
              return multi2.sinter(`G:${friend}:${USER_FOES_WITH}`, onpageUserSet, function(e, m) {
                if (m) {
                  return graph.foaf_foes = graph.foaf_foes.concat(m);
                }
              });
            })(friend);
          }
          return multi2.exec(function() {
            callback(graph);
            return client.del(onpageUserSet);
          });
        });
        return multi1.exec();
      });
    }
  };

}).call(this);
