// Generated by CoffeeScript 2.6.1
(function() {
  var BASE62_CHARS, BASE_DELAY, MAX_BACKOFF, USERNAME_RE, VERIFICATION_TTL, client, crypto, https, redis;

  crypto = require('crypto');

  https = require('https');

  redis = require('redis');

  client = redis.createClient(null, process.env.REDIS_HOST || null);

  VERIFICATION_TTL = 3600;

  MAX_BACKOFF = 120;

  BASE_DELAY = 5;

  BASE62_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

  USERNAME_RE = /^[a-zA-Z0-9_-]+$/;

  module.exports = {
    generateVerificationToken: function() {
      var b, bytes, i, len, token;
      bytes = crypto.randomBytes(18);
      token = '';
      for (i = 0, len = bytes.length; i < len; i++) {
        b = bytes[i];
        token += BASE62_CHARS[b % 62];
      }
      return `HS:${token}`;
    },
    generateAuthToken: function(callback) {
      return crypto.randomBytes(32, function(err, buf) {
        return callback(buf.toString('hex'));
      });
    },
    validateUsername: function(username) {
      return username && typeof username === 'string' && USERNAME_RE.test(username);
    },
    startVerification: function(username, callback) {
      var authKey, pendingKey;
      if (!this.validateUsername(username)) {
        return callback({
          error: 'Invalid username',
          code: -1
        });
      }
      pendingKey = `V:${username}:pending`;
      authKey = `V:${username}:auth_token`;
      // Check if already verified
      return client.get(authKey, (err, existingToken) => {
        if (existingToken) {
          return callback({
            code: 2,
            status: 'already_verified',
            message: 'Already verified. Start again to re-verify.'
          });
        }
        // Check for existing pending verification (idempotent)
        return client.hgetall(pendingKey, (err, pending) => {
          var now, token;
          if (pending && pending.token) {
            return callback({
              code: 1,
              username: username,
              verification_token: pending.token,
              instructions: "Add this token to your Hacker News profile's 'about' section.",
              expires_in: VERIFICATION_TTL
            });
          }
          // Generate new verification
          token = this.generateVerificationToken();
          now = new Date().toISOString();
          client.hmset(pendingKey, 'token', token, 'created_at', now, 'attempts', '0', 'last_attempt', '');
          client.expire(pendingKey, VERIFICATION_TTL);
          return callback({
            code: 1,
            username: username,
            verification_token: token,
            instructions: "Add this token to your Hacker News profile's 'about' section.",
            expires_in: VERIFICATION_TTL
          });
        });
      });
    },
    checkVerification: function(username, callback) {
      var pendingKey;
      if (!this.validateUsername(username)) {
        return callback({
          error: 'Invalid username',
          code: -1
        });
      }
      pendingKey = `V:${username}:pending`;
      return client.hgetall(pendingKey, (err, pending) => {
        var attempts, delay, elapsed, lastAttempt, now, remaining;
        if (!pending || !pending.token) {
          return callback({
            code: -2,
            status: 'expired',
            message: 'Verification request has expired. Please start again.'
          });
        }
        attempts = parseInt(pending.attempts, 10) || 0;
        lastAttempt = pending.last_attempt;
        now = Date.now();
        delay = this.calculateBackoff(attempts);
        // Enforce backoff
        if (lastAttempt) {
          elapsed = (now - new Date(lastAttempt).getTime()) / 1000;
          if (elapsed < delay) {
            remaining = Math.ceil(delay - elapsed);
            return callback({
              code: -1,
              status: 'rate_limited',
              message: 'Please wait before checking again.',
              retry_after: remaining
            });
          }
        }
        // Update attempt count
        client.hincrby(pendingKey, 'attempts', 1);
        client.hset(pendingKey, 'last_attempt', new Date().toISOString());
        // Scrape HN profile
        return this.scrapeHNProfile(username, (err, foundToken) => {
          var nextDelay;
          if (err) {
            return callback({
              code: 0,
              status: 'error',
              message: 'Could not reach Hacker News. Try again shortly.',
              retry_after: delay
            });
          }
          if (foundToken && foundToken === pending.token) {
            // Verification succeeded
            return this.generateAuthToken(function(authToken) {
              client.set(`V:${username}:auth_token`, authToken);
              client.set(`V:${username}:verified_at`, new Date().toISOString());
              client.del(pendingKey);
              return callback({
                code: 1,
                status: 'verified',
                auth_token: authToken
              });
            });
          } else {
            nextDelay = this.calculateBackoff(attempts + 1);
            return callback({
              code: 0,
              status: 'pending',
              message: `Token not found in profile. Next check in ${nextDelay}s.`,
              retry_after: nextDelay
            });
          }
        });
      });
    },
    checkStatus: function(username, authToken, callback) {
      if (!this.validateUsername(username)) {
        return callback({
          code: 0,
          status: 'unverified'
        });
      }
      if (!authToken) {
        return callback({
          code: 0,
          status: 'unverified'
        });
      }
      return this.validateAuthToken(username, authToken, function(valid) {
        if (valid) {
          return client.get(`V:${username}:verified_at`, function(err, verifiedAt) {
            return callback({
              code: 1,
              status: 'verified',
              verified_at: verifiedAt
            });
          });
        } else {
          return callback({
            code: 0,
            status: 'unverified'
          });
        }
      });
    },
    validateAuthToken: function(username, providedToken, callback) {
      var key;
      key = `V:${username}:auth_token`;
      return client.get(key, function(err, storedToken) {
        var valid;
        if (err || !storedToken || !providedToken) {
          return callback(false);
        }
        // Ensure same length for timingSafeEqual
        if (providedToken.length !== storedToken.length) {
          return callback(false);
        }
        try {
          valid = crypto.timingSafeEqual(Buffer.from(providedToken, 'utf8'), Buffer.from(storedToken, 'utf8'));
          return callback(valid);
        } catch (error) {
          return callback(false);
        }
      });
    },
    scrapeHNProfile: function(username, callback) {
      var options, req, url;
      url = `https://news.ycombinator.com/user?id=${encodeURIComponent(username)}`;
      options = {
        hostname: 'news.ycombinator.com',
        path: `/user?id=${encodeURIComponent(username)}`,
        headers: {
          'User-Agent': 'HackerSmacker/1.0 (https://www.hackersmacker.org)'
        },
        timeout: 10000
      };
      req = https.get(options, function(res) {
        var body;
        body = '';
        res.on('data', function(chunk) {
          return body += chunk;
        });
        return res.on('end', function() {
          var aboutContent, aboutMatch, tokenMatch;
          // HN profile: about field is in a <td> after the "about:" label
          aboutMatch = body.match(/about:<\/td><td>([\s\S]*?)<\/td>/i);
          if (aboutMatch) {
            aboutContent = aboutMatch[1];
            tokenMatch = aboutContent.match(/HS:[a-zA-Z0-9]{24}/);
            return callback(null, (tokenMatch != null ? tokenMatch[0] : void 0) || null);
          } else {
            return callback(null, null);
          }
        });
      });
      req.on('error', function(err) {
        return callback(err, null);
      });
      return req.on('timeout', function() {
        req.destroy();
        return callback(new Error('Request timed out'), null);
      });
    },
    calculateBackoff: function(attempts) {
      return Math.min(BASE_DELAY * Math.pow(2, attempts), MAX_BACKOFF);
    }
  };

}).call(this);
