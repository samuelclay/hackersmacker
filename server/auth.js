// Generated by CoffeeScript 2.6.1
(function() {
  var BASE62_CHARS, MIN_CHECK_INTERVAL, USERNAME_RE, client, crypto, https, redis;

  crypto = require('crypto');

  https = require('https');

  redis = require('redis');

  client = redis.createClient(null, process.env.REDIS_HOST || null);

  MIN_CHECK_INTERVAL = 3; // seconds between HN scrapes

  BASE62_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

  USERNAME_RE = /^[a-zA-Z0-9_-]+$/;

  module.exports = {
    generateVerificationToken: function(username) {
      var b, bytes, code, i, len;
      bytes = crypto.randomBytes(18);
      code = '';
      for (i = 0, len = bytes.length; i < len; i++) {
        b = bytes[i];
        code += BASE62_CHARS[b % 62];
      }
      return `https://www.hackersmacker.org/user/${username}?hs=${code}`;
    },
    generateAuthToken: function(callback) {
      return crypto.randomBytes(32, function(err, buf) {
        return callback(buf.toString('hex'));
      });
    },
    validateUsername: function(username) {
      return username && typeof username === 'string' && USERNAME_RE.test(username);
    },
    startVerification: function(username, callback) {
      var authKey, pendingKey;
      if (!this.validateUsername(username)) {
        return callback({
          error: 'Invalid username',
          code: -1
        });
      }
      pendingKey = `V:${username}:pending`;
      authKey = `V:${username}:auth_token`;
      // Check if already verified — return auth token so extension can recover
      return client.get(authKey, (err, existingToken) => {
        if (existingToken) {
          return callback({
            code: 2,
            status: 'already_verified',
            auth_token: existingToken
          });
        }
        // Return existing token or generate one — token is stable per user
        return client.hgetall(pendingKey, (err, pending) => {
          var now, token;
          if (pending && pending.token) {
            return callback({
              code: 1,
              username: username,
              verification_token: pending.token
            });
          }
          // Generate new verification (first time only)
          token = this.generateVerificationToken(username);
          now = new Date().toISOString();
          client.hmset(pendingKey, 'token', token, 'created_at', now, 'last_attempt', '');
          // No TTL — token lives until verified
          return callback({
            code: 1,
            username: username,
            verification_token: token
          });
        });
      });
    },
    checkVerification: function(username, callback) {
      var pendingKey;
      if (!this.validateUsername(username)) {
        return callback({
          error: 'Invalid username',
          code: -1
        });
      }
      pendingKey = `V:${username}:pending`;
      return client.hgetall(pendingKey, (err, pending) => {
        var elapsed, now, remaining;
        if (!pending || !pending.token) {
          return callback({
            code: -2,
            status: 'no_pending',
            message: 'No verification in progress. Please start verification first.'
          });
        }
        // Light rate limit — just prevent hammering HN
        now = Date.now();
        if (pending.last_attempt) {
          elapsed = (now - new Date(pending.last_attempt).getTime()) / 1000;
          if (elapsed < MIN_CHECK_INTERVAL) {
            remaining = Math.ceil(MIN_CHECK_INTERVAL - elapsed);
            return callback({
              code: -1,
              status: 'rate_limited',
              retry_after: remaining
            });
          }
        }
        client.hset(pendingKey, 'last_attempt', new Date().toISOString());
        // Scrape HN profile
        return this.scrapeHNProfile(username, (err, foundToken) => {
          if (err) {
            return callback({
              code: 0,
              status: 'error',
              message: 'Could not reach Hacker News. Try again shortly.'
            });
          }
          if (foundToken && foundToken === pending.token) {
            // Verification succeeded
            return this.generateAuthToken(function(authToken) {
              client.set(`V:${username}:auth_token`, authToken);
              client.set(`V:${username}:verified_at`, new Date().toISOString());
              client.del(pendingKey);
              return callback({
                code: 1,
                status: 'verified',
                auth_token: authToken
              });
            });
          } else {
            return callback({
              code: 0,
              status: 'pending',
              message: 'Token not found in your HN profile yet.'
            });
          }
        });
      });
    },
    checkStatus: function(username, authToken, callback) {
      if (!this.validateUsername(username)) {
        return callback({
          code: 0,
          status: 'unverified'
        });
      }
      if (!authToken) {
        return callback({
          code: 0,
          status: 'unverified'
        });
      }
      return this.validateAuthToken(username, authToken, function(valid) {
        if (valid) {
          return client.get(`V:${username}:verified_at`, function(err, verifiedAt) {
            return callback({
              code: 1,
              status: 'verified',
              verified_at: verifiedAt
            });
          });
        } else {
          return callback({
            code: 0,
            status: 'unverified'
          });
        }
      });
    },
    validateAuthToken: function(username, providedToken, callback) {
      var key;
      key = `V:${username}:auth_token`;
      return client.get(key, function(err, storedToken) {
        var valid;
        if (err || !storedToken || !providedToken) {
          return callback(false);
        }
        if (providedToken.length !== storedToken.length) {
          return callback(false);
        }
        try {
          valid = crypto.timingSafeEqual(Buffer.from(providedToken, 'utf8'), Buffer.from(storedToken, 'utf8'));
          return callback(valid);
        } catch (error) {
          return callback(false);
        }
      });
    },
    scrapeHNProfile: function(username, callback) {
      var options, req;
      options = {
        hostname: 'news.ycombinator.com',
        path: `/user?id=${encodeURIComponent(username)}`,
        headers: {
          'User-Agent': 'HackerSmacker/1.0 (https://www.hackersmacker.org)'
        },
        timeout: 10000
      };
      req = https.get(options, function(res) {
        var body;
        body = '';
        res.on('data', function(chunk) {
          return body += chunk;
        });
        return res.on('end', function() {
          var aboutContent, aboutMatch, fullToken, normalized, tokenMatch;
          aboutMatch = body.match(/about:<\/td><td[^>]*>([\s\S]*?)<\/td>/i);
          if (aboutMatch) {
            aboutContent = aboutMatch[1];
            // HN encodes / as &#x2F;
            normalized = aboutContent.replace(/&#x2F;/g, '/').replace(/&amp;/g, '&');
            tokenMatch = normalized.match(/hackersmacker\.org\/user\/([a-zA-Z0-9_-]+)\?hs=([a-zA-Z0-9]{18})/);
            if (tokenMatch) {
              fullToken = `https://www.hackersmacker.org/user/${tokenMatch[1]}?hs=${tokenMatch[2]}`;
              return callback(null, fullToken);
            } else {
              return callback(null, null);
            }
          } else {
            return callback(null, null);
          }
        });
      });
      req.on('error', function(err) {
        return callback(err, null);
      });
      return req.on('timeout', function() {
        req.destroy();
        return callback(new Error('Request timed out'), null);
      });
    }
  };

}).call(this);
